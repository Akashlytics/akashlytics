import { Button } from "@material-ui/core";
import React, { useEffect, useState } from "react";
import { SigningStargateClient, MsgSend, MsgDelegate, makeSignDoc, AminoTypes } from "@cosmjs/stargate";
import { SigningCosmosClient } from "@cosmjs/launchpad";
import { DirectSecp256k1HdWallet, Registry, Writer, Coin, Tx } from "@cosmjs/proto-signing";
import { AminoMsgSend, AminoMsgDelegate } from "@cosmjs/amino";
import { Any } from "@cosmjs/stargate/build/codec/google/protobuf/any";
import protobuf from "protobufjs/minimal";
import { MsgCloseDeployment, MsgRevokeCertificate, MsgCreateCertificate, MsgCreateDeployment } from "./ProtoAkashTypes";

import DemoDeployYaml from "../../demo.deploy.yml";

import rsa from 'js-x509-utils';
var rs = require("jsrsasign");
const yaml = require('js-yaml');

const rpcEnpoint = "http://localhost:4242/http://rpc.akash.forbole.com";
const apiEndpoint = "http://localhost:4242/http://135.181.60.250:1317";
// const rpcEnpoint = "http://localhost:26656";
// const apiEndpoint = "http://localhost:1317";

// import * as protoDeployment from '../../proto/gen/akash/deployment/v1beta1/deployment_pb';
// console.log(protoDeployment);
// var MsgCloseDeployment = new protoDeployment.MsgCloseDeployment();
// MsgCloseDeployment.create = function (obj) {
//     return { ...obj };
// }
// MsgCloseDeployment.encode = function (obj, writer) {
//     debugger;
//     return protoDeployment.MsgCloseDeployment.serializeBinaryToWriter(new protoDeployment.MsgCloseDeployment(obj), writer);
// }
// console.log(MsgCloseDeployment);
//import { SigningCosmWasmClient } from "secretjs";

// const baseCustomMsgDelegate = {
//     id: {
//         owner: "",
//         dseq: ""
//     }
// };
// const CustomMsgDelegate = {
//     // Adapted from autogenerated MsgDelegate implementation
//     encode(
//         message,
//         writer = protobuf.Writer.create(),
//     ) {
//         console.log("test");
//         console.log(message);
//         writer.string(JSON.stringify(message));
//         //writer.string(message.id.dseq);
//         //   writer.uint32(10).string(message.customDelegatorAddress ?? "");
//         //   writer.uint32(18).string(message.customValidatorAddress ?? "");
//         //   if (message.customAmount !== undefined && message.customAmount !== undefined) {
//         //     Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
//         //   }
//         return writer;
//     },

//     decode() {
//         throw new Error("decode method should not be required");
//     },

//     fromJSON() {
//         throw new Error("fromJSON method should not be required");
//     },

//     fromPartial(object) {
//         const message = { ...baseCustomMsgDelegate };
//         if (object.id.owner !== undefined && object.id.owner !== null) {
//             message.id.owner = object.id.owner;
//         } else {
//             message.id.owner = "";
//         }
//         if (object.id.dseq !== undefined && object.id.dseq !== null) {
//             message.id.dseq = object.id.dseq;
//         } else {
//             message.id.dseq = "";
//         }
//         return message;
//     },

//     toJSON() {
//         throw new Error("toJSON method should not be required");
//     },
// };
// const customAminoTypes = new AminoTypes({
//     additions: {
//         "/akash.deployment.v1beta1.MsgCloseDeployment": {
//             aminoType: "/akash.deployment.v1beta1.MsgCloseDeployment",
//             toAmino: (msg) => {
//                 return {
//                     id: {
//                         owner: msg.id.owner,
//                         dseq: msg.id.dseq
//                     }
//                 };
//             },
//             fromAmino: (msg) => ({
//                 id: {
//                     owner: msg.id.owner,
//                     dseq: msg.id.dseq
//                 }
//             }),
//         },
//     },
// });

const fee = {
    gas: "120000",
    amount: [{
        "denom": "akt",
        "amount": "0.0012"
    }]
}

async function getKeplr() {
    if (window.keplr) {
        return window.keplr;
    }

    if (document.readyState === "complete") {
        return window.keplr;
    }

    return new Promise((resolve) => {
        const documentStateChange = (event) => {
            if (
                event.target &&
                (event.target).readyState === "complete"
            ) {
                resolve(window.keplr);
                document.removeEventListener("readystatechange", documentStateChange);
            }
        };

        document.addEventListener("readystatechange", documentStateChange);
    });
}

const chainId = "akashnet-2";

export function DeployTool() {

    const [selectedWallet, setSelectedWallet] = useState(null);
    const [deployments, setDeployments] = useState([]);
    const [validCertificates, setValidCertificates] = useState([]);

    useEffect(async () => {
        const keplr = await getKeplr();
        await keplr.enable(chainId);

        const offlineSigner = window.getOfflineSigner(chainId);

        const key = await keplr.getKey(chainId);
        const accounts = await offlineSigner.getAccounts();
        console.log(accounts);

        setSelectedWallet(key);

        // const signed = await keplr.signDirect(key.bech32Address, offlineSigner, {
        //     bodyBytes: [0,1,3],
        //     chainId: chainId
        // });

        //     const amount = 1000;
        // const result = await cosmJS.sendTokens("cosmos1slzxpc23f62ezmmvhkrululttn6lpsq506e2uc", [{
        //     denom: "uakt",
        //     amount: amount.toString(),
        // }]);

        const txData = [
            {
                "id": {
                    "owner": "akash1ngz3pe5dat3xkv306r23kt7y8kns3sfxxtrzlm",
                    "dseq": "564141"
                }
            }
        ];

        //makeSignDoc([closeDeploymentJson], fee, chainId, "Test Akashlytics");


        // const registry = new Registry();
        // const client  = new SigningStargateClient(
        //     "http://public-rpc2.akash.vitwit.com",
        //     offlineSigner,
        //     { registry: registry }
        // );

        // const res = await client.queryClient.bank.allBalances(key.bech32Address);

        // console.log(client);

        const response = await fetch("/api/getDeploymentsByAddress/" + accounts[0].address);
        const deployments = await response.json();
        setDeployments(deployments);

        loadValidCertificates(accounts[0].address);
    }, []);

    async function loadValidCertificates(owner) {
        const response = await fetch(apiEndpoint + "/akash/cert/v1beta1/certificates/list?filter.state=valid&filter.owner=" + owner);
        const data = await response.json();

        setValidCertificates(data.certificates);
    }

    // TODO: Verify
    async function getCurrentHeight() {
        const response = await fetch(apiEndpoint + "/blocks/latest");
        const data = await response.json();

        const height = parseInt(data.block.header.height); // TODO parseInt?
        return height;
    }

    async function closeDeployment(deployment) {
        const keplr = await getKeplr();

        const offlineSigner = window.getOfflineSigner(chainId);
        const accounts = await offlineSigner.getAccounts();

        const endpoint = "http://localhost:1317/http://rpc.akash.forbole.com";

        const customRegistry = new Registry();
        //registry.register("/custom.MsgCustom", MsgSend);
        //customRegistry.register("/akash.deployment.v1beta1.MsgCloseDeployment", CustomMsgDelegate);
        debugger;
        //customRegistry.register("/akash.deployment.v1beta1.MsgCloseDeployment", MsgCloseDeployment);



        //customRegistry.register("MsgCloseDeploymentId", MsgCloseDeploymentId);
        customRegistry.register("/akash.deployment.v1beta1.MsgCloseDeployment", MsgCloseDeployment);


        const client = await SigningStargateClient.connectWithSigner(endpoint, offlineSigner, {
            registry: customRegistry,
            //aminoTypes: customAminoTypes
        });
        //client.registry.register("deployment/close-deployment", MsgDelegate);

        //const txResult = await client.sendTokens(selectedWallet.bech32Address, "akash1slzxpc23f62ezmmvhkrululttn6lpsq5zp5d9z", [{ amount: "100000", denom: "uakt" }], "Test Akashlytics Send");

        const closeDeploymentJson = {
            "typeUrl": "/akash.deployment.v1beta1.MsgCloseDeployment",
            "value": {
                "id": {
                    "owner": selectedWallet.bech32Address,
                    "dseq": deployment.dseq
                }
            }
        };
        //MsgDelegate.create()

        const fee = {
            gas: "120000",
            amount: [{
                "denom": "akt",
                "amount": "0.0012"
            }]
        }

        //const tmClient = await Tendermint34Client.connect("http://rpc.akash.forbole.com:80");
        //await client.signAmino(selectedWallet.bech32Address, )

        await client.signAndBroadcast(selectedWallet.bech32Address, [closeDeploymentJson], fee, "Test Akashlytics");
        // await client.signAndBroadcast(selectedWallet.bech32Address, [{
        //     typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        //     value: {
        //         fromAddress: "akash1slzxpc23f62ezmmvhkrululttn6lpsq5zp5d9z",
        //         toAddress: "akash1slzxpc23f62ezmmvhkrululttn6lpsq5zp5d9z",
        //         amount: [{
        //             "denom": "uakt",
        //             "amount": "1000"
        //         }]
        //     }
        // }], fee, "Test Akashlytics");
    }

    async function createDeployment() {
        const fromAddress = selectedWallet.bech32Address;

        const flags = {};
        const response = await fetch(DemoDeployYaml);
        const txt = await response.text();
        const doc = yaml.load(txt);

        const dd = await NewDeploymentData(doc, flags, fromAddress); // TODO Flags

        const msg = {
            id: dd.deploymentId,
            groups: dd.groups,
            version: dd.version,
            deposit: dd.deposit
        };

        const txData = {
            "typeUrl": "/akash.deployment.v1beta1.MsgCreateDeployment",
            "value": msg
        }

        console.log(txData);

        debugger;
        const err = MsgCreateDeployment.verify(msg);
        const encoded = MsgCreateDeployment.fromObject(msg);
        const decoded = MsgCreateDeployment.toObject(encoded);
        console.log(decoded);

        if(err) throw err;

        const offlineSigner = window.getOfflineSigner(chainId);

        const customRegistry = new Registry();
        customRegistry.register("/akash.deployment.v1beta1.MsgCreateDeployment", MsgCreateDeployment);

        const client = await SigningStargateClient.connectWithSigner(rpcEnpoint, offlineSigner, {
            registry: customRegistry
        });

        await client.signAndBroadcast(fromAddress, [txData], fee);
    }

    function ParseServiceProtocol(input) {
        let result;

        // This is not a case sensitive parse, so make all input
        // uppercase
        if (input) {
            input = input.toUpperCase();
        }

        switch (input) {
            case "TCP", "", undefined: // The empty string (no input) implies TCP
                result = "TCP";
                break;
            case "UDP":
                result = "UDP";
                break;
            default:
                throw "ErrUnsupportedServiceProtocol";
        }

        return result;
    }

    function parseSizeStr(str) {
        const suffixPos = str.indexOf("Mi");// Handle other suffix
        const numberStr = str.substring(0, suffixPos);
        const result = parseInt(numberStr) * 1024 * 1024;
        return result.toString();
    }

    // Port of: func (sdl *v2ComputeResources) toResourceUnits() types.ResourceUnits
    function toResourceUnits(computeResources) {
        if (!computeResources) return {};
debugger;
        let units = {};
        if (computeResources.cpu) {
            units.cpu = {
                units: { val: (computeResources.cpu.units * 1000).toString() },
                //attributes: computeResources.cpu.attributes TODO
            }
        }
        if (computeResources.memory) {
            units.memory = {
                quantity: { val: parseSizeStr(computeResources.memory.size) },
                //attributes: computeResources.memory.attributes TODO
            }
        }
        if (computeResources.storage) {
            units.storage = {
                quantity: { val: parseSizeStr(computeResources.storage.size) },
                //attributes: computeResources.storage.attributes TODO
            }
        }

        return units;
    }

    // Port of:    func (sdl *v2) Manifest() (manifest.Manifest, error
    function Manifest(yamlJson) {
        let groups = {};

        Object.keys(yamlJson.services).forEach(svcName => {
            const svc = yamlJson.services[svcName];
            const depl = yamlJson.deployment[svcName];

            Object.keys(depl).forEach(placementName => {
                const svcdepl = depl[placementName];
                let group = groups[placementName];

                if (!group) {
                    group = {
                        name: placementName,
                        services: []
                    };
                    groups[placementName] = group;
                }

                const compute = yamlJson.profiles.compute[svcdepl.profile];

                const msvc = {
                    name: svcName,
                    image: svc.image,
                    args: svc.args,
                    env: svc.env,
                    resources: toResourceUnits(compute.resources),
                    count: svcdepl.count,
                    expose: []
                };

                svc.expose.forEach((expose) => {
                    const proto = ParseServiceProtocol(expose.proto);

                    if (expose.to && expose.to.length > 0) {
                        expose.to.forEach(to => {
                            msvc.expose.push({
                                service: to.service,
                                port: expose.port,
                                externalPort: expose.as,
                                proto: proto,
                                global: to.global,
                                hosts: expose.accept && expose.accept.items
                            });
                        })
                    } else {
                        msvc.expose.push({
                            service: "",
                            port: expose.port,
                            externalPort: expose.as,
                            proto: proto,
                            global: false,
                            hosts: expose.accept.items
                        });
                    }
                });

                msvc.expose = msvc.expose.sort((a, b) => {
                    if (a.service != b.service) {
                        return a.service < b.service;
                    }
                    if (a.port != b.port) {
                        return a.port < b.port;
                    }
                    if (a.proto != b.proto) {
                        return a.proto < b.proto;
                    }
                    if (a.global != b.global) {
                        return a.global < b.global;
                    }
                    return false;
                });

                group.services.push(msvc);
            })
        });

        let names = Object.keys(groups);
        names = names.sort((a, b) => a < b);

        let result = names.map(name => groups[name]);
        return result;
    }

    function shouldBeIngress(expose) {
        return expose.proto == "TCP" && expose.global && 80 == exposeExternalPort(expose);
    }

    function exposeExternalPort(expose) {
        if (expose.externalPort === 0) {
            return expose.port;
        }

        return expose.externalPort;
    }

    function sortKeys(obj_1) {
        var key = Object.keys(obj_1)
            .sort(function order(key1, key2) {
                if (key1 < key2) return -1;
                else if (key1 > key2) return +1;
                else return 0;
            });

        // Taking the object in 'temp' object
        // and deleting the original object.
        var temp = {};

        for (var i = 0; i < key.length; i++) {
            temp[key[i]] = obj_1[key[i]];
            delete obj_1[key[i]];
        }

        // Copying the object from 'temp' to 
        // 'original object'.
        for (var i = 0; i < key.length; i++) {
            obj_1[key[i]] = temp[key[i]];
        }
        return obj_1;
    }

    function DeploymentGroups(yamlJson) {
        let groups = {};

        Object.keys(yamlJson.services).forEach(svcName => {
            const svc = yamlJson.services[svcName];
            const depl = yamlJson.deployment[svcName];

            Object.keys(depl).forEach(placementName => {
                const svcdepl = depl[placementName];
                const compute = yamlJson.profiles.compute[svcdepl.profile];
                const infra = yamlJson.profiles.placement[placementName];
                const price = infra.pricing[svcdepl.profile];
                price.amount = price.amount.toString(); // Interpreted as number otherwise

                let group = groups[placementName];
                
                if (!group) {
                    group = {
                        name: placementName,
                        requirements: {
                            attributes: Object.keys(infra.attributes).map(key => ({ key: key, value: infra.attributes[key] })),
                            signed_by: {
                                all_of: infra.signedBy.allOf,
                                any_of: infra.signedBy.anyOf
                            }
                        },
                        resources: []
                    };

                    group.requirements.attributes = group.requirements.attributes.sort((a, b) => a.key < b.key);

                    groups[group.name] = group;
                }


                const resources = {
                    resources: toResourceUnits(compute.resources), // Chanded resources => unit
                    price: price,
                    count: svcdepl.count
                };

                let endpoints = [];

                svc.expose.forEach((expose) => {
                    expose.to.forEach(to => {
                        if (to.global) {
                            const proto = ParseServiceProtocol(expose.proto);

                            let v = {
                                port: expose.port,
                                externalPort: expose.as,
                                proto: proto,
                                service: to.service,
                                global: to.global,
                                hosts: expose.accept?.items
                            };

                            // TODO Enum
                            const Endpoint_SHARED_HTTP = 0;
                            const Endpoint_RANDOM_PORT = 1;

                            let kind = Endpoint_RANDOM_PORT;

                            if (shouldBeIngress(v)) {
                                kind = Endpoint_SHARED_HTTP;
                            }

                            endpoints.push({ kind: kind });
                        }
                    });

                    resources.resources.endpoints = endpoints;
                    group.resources.push(resources);
                });
            });
        });

        let names = Object.keys(groups);
        names = names.sort((a, b) => a < b);

        let result = names.map(name => groups[name]);
        return result;
    }

    // https://github.com/cosmos/cosmos-sdk/blob/9fd866e3820b3510010ae172b682d71594cd8c14/types/utils.go#L29
    function SortJSON(jsonStr) {
        return JSON.stringify(JSON.parse(jsonStr));
    }

    function _arrayBufferToBase64(buffer) {
        var binary = '';
        var bytes = new Uint8Array(buffer);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    // https://github.com/ovrclk/akash/blob/04e7a7667dd94b5a15fa039e4f7df5c9ad93be4f/sdl/sdl.go#L120
    async function ManifestVersion(manifest) {
        var enc = new TextEncoder();
        let m = JSON.stringify(manifest);
        let sortedBytes = enc.encode(SortJSON(m));

        let sum = await crypto.subtle.digest('SHA-256', sortedBytes);

        let base64 = _arrayBufferToBase64(sum);

        return base64;
    }

    // https://github.com/ovrclk/akash/blob/04e7a7667dd94b5a15fa039e4f7df5c9ad93be4f/x/deployment/client/cli/flags.go#L51
    function DeploymentIDFromFlagsForOwner(flags, owner) {
        let id = {
            owner: owner,
        };

        //TODO
        // if id.DSeq, err = flags.GetUint64("dseq"); err != nil {
        //     return id, err
        // }

        return id;
    }


    function DepositFromFlags(flags) {
        // let val = flags["deposit"];

        // if(!val) return {};

        // return ParseCoinNormalized(val)
        // TODO
        return {
            "denom": "uakt",
            "amount": "5000000"
        };
    }

    async function NewDeploymentData(yamlJson, flags, fromAddress) {
        const groups = DeploymentGroups(yamlJson);
        const mani = Manifest(yamlJson);
        const ver = await ManifestVersion(mani);
        const id = DeploymentIDFromFlagsForOwner(flags, fromAddress); // TODO: handle flags
        const deposit = DepositFromFlags();

        if (!id.dseq) {
            id.dseq = (await getCurrentHeight());
        }

        return {
            sdl: yamlJson,
            manifest: mani,
            groups: groups,
            deploymentId: id,
            orderId: [],
            leaseId: [],
            version: ver,
            deposit: deposit
        };
    }

    async function revokeCertificate(cert) {
        const offlineSigner = window.getOfflineSigner(chainId);

        const customRegistry = new Registry();
        customRegistry.register("/akash.cert.v1beta1.MsgRevokeCertificate", MsgRevokeCertificate);


        const client = await SigningStargateClient.connectWithSigner(rpcEnpoint, offlineSigner, {
            registry: customRegistry
        });

        const revokeCertificateJson = {
            "typeUrl": "/akash.cert.v1beta1.MsgRevokeCertificate",
            "value": {
                "id": {
                    "owner": selectedWallet.bech32Address,
                    "serial": cert.serial
                }
            }
        };

        await client.signAndBroadcast(selectedWallet.bech32Address, [revokeCertificateJson], fee, "Test Akashlytics");
    }

    async function createCertificate() {
        debugger;
        const fromAddress = selectedWallet.bech32Address;
        const notBefore = new Date();
        let notAfter = new Date();
        notAfter.setFullYear(notBefore.getFullYear() + 1);

        // STEP1. generate a key pair
        var kp = rs.KEYUTIL.generateKeypair("EC", "secp256r1");
        var prv = kp.prvKeyObj;
        var pub = kp.pubKeyObj;
        var prvpem = rs.KEYUTIL.getPEM(prv, "PKCS8PRV");
        var pubpem = rs.KEYUTIL.getPEM(pub, "PKCS8PUB").replaceAll("PUBLIC KEY", "EC PUBLIC KEY");

        // STEP2. specify certificate parameters
        var cert = new rs.KJUR.asn1.x509.Certificate({
            version: 3,
            serial: { int: Math.floor((new Date()).getTime() * 1000) },
            issuer: { str: "/CN=" + fromAddress },
            notbefore: notBefore,
            notafter: notAfter,
            subject: { str: "/CN=" + fromAddress },
            //subjectAltName: {array: [{oid: "2.23.133.2.6", value: "v0.0.1"}]},
            sbjpubkey: pub, // can specify public key object or PEM string
            ext: [
                { extname: "keyUsage", critical: true, names: ["keyEncipherment", "dataEncipherment"] },
                {
                    extname: "extKeyUsage",
                    array: [{ name: 'clientAuth' }]
                },
                { extname: "basicConstraints", cA: true, critical: true }
            ],
            sigalg: "SHA256withECDSA",
            cakey: prv // can specify private key object or PEM string
        });

        const crtpem = cert.getPEM();

        // STEP3. show PEM strings of keys and a certificate
        console.log(prvpem);
        console.log(pubpem);
        console.log(crtpem);

        const createCertificateMsg = {
            "typeUrl": "/akash.cert.v1beta1.MsgCreateCertificate",
            "value": {
                owner: fromAddress,
                cert: window.forge.util.encode64(crtpem),
                pubkey: window.forge.util.encode64(pubpem)
            }
        }

        const offlineSigner = window.getOfflineSigner(chainId);

        const customRegistry = new Registry();
        customRegistry.register("/akash.cert.v1beta1.MsgCreateCertificate", MsgCreateCertificate);

        const client = await SigningStargateClient.connectWithSigner(rpcEnpoint, offlineSigner, {
            registry: customRegistry
        });

        await client.signAndBroadcast(selectedWallet.bech32Address, [createCertificateMsg], fee, "Test Akashlytics");
    }

    return (
        <div className="container text-on-black">
            {selectedWallet && (
                <>
                    <h1>{selectedWallet.name}</h1>
                    <h2>{selectedWallet.bech32Address}</h2>

                    <h2>Deployments</h2>
                    {deployments.map(deployment => (
                        <div key={deployment.id}>
                            {deployment.state}
                            {deployment.state === "active" && (
                                <Button color="primary" onClick={() => closeDeployment(deployment)}>Close</Button>
                            )}
                        </div>
                    ))}


                    <h2>Certificates</h2>
                    {validCertificates.length > 0 ?
                        validCertificates.map(cert => (
                            <div key={cert.serial}>
                                {cert.serial}
                                <Button color="primary" onClick={() => revokeCertificate(cert)}>Revoke</Button>
                            </div>
                        )) : (
                            <div>
                                <Button color="primary" onClick={() => createCertificate()}>Create Certificate</Button>
                            </div>
                        )}
                    <br />

                    <Button color="primary" onClick={() => createDeployment()}>Create Deployment</Button>
                </>
            )}
        </div>
    )
}